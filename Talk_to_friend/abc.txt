import React, { useEffect, useRef, useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import InCallManager from 'react-native-incall-manager';
import { RTCPeerConnection, RTCSessionDescription, mediaDevices } from 'react-native-webrtc';
import { Mic, MicOff, Phonecall_end, Speaker, SpeakerOff } from '../Common/icon';

const OngoingCallScreen = ({ route, navigation }) => {
  const { mode, socket, userId, receiverId, isCaller } = route.params;
  
  const [isMuted, setIsMuted] = useState(false);
  const [isSpeakerOn, setIsSpeakerOn] = useState(false);
  const [localStream, setLocalStream] = useState(null);
  const [remoteStream, setRemoteStream] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState('Initializing...');
  const [isNegotiating, setIsNegotiating] = useState(false);

  const peerConnection = useRef(null);
  const streamRef = useRef(null);

  const iceServers = {
    iceServers: [
      { 
        urls: [
          'stun:stun.l.google.com:19302',
          'stun:stun1.l.google.com:19302',
          'stun:stun2.l.google.com:19302'
        ],
      },
      {
        urls: 'turn:numb.viagenie.ca',
        username: 'webrtc@live.com',
        credential: 'muazkh'
      }
    ],
    iceCandidatePoolSize: 10,
  };

  useEffect(() => {
    setupAudioSession();
    setupWebRTC();
    return () => cleanup();
  }, []);

  const setupAudioSession = async () => {
    try {
      await InCallManager.start({ media: 'audio' });
      await InCallManager.setKeepScreenOn(true);
      await InCallManager.setForceSpeakerphoneOn(false);
      console.log('Audio session initialized');
    } catch (err) {
      console.error('Error setting up audio session:', err);
    }
  };

  useEffect(() => {
    if (!socket) return;

    const handleSocketEvents = () => {
      socket.on('offer', handleOffer);
      socket.on('answer', handleAnswer);
      socket.on('ice-candidate', handleNewIceCandidate);
      socket.on('endCall', handleEndCallFromRemote);
      socket.on('callEnded', handleEndCallFromRemote);
    };

    handleSocketEvents();

    return () => {
      socket.off('offer');
      socket.off('answer');
      socket.off('ice-candidate');
      socket.off('endCall');
      socket.off('callEnded');
    };
  }, [socket]);

  const setupWebRTC = async () => {
    try {
      console.log('Setting up WebRTC...');
      setConnectionStatus('Setting up connection...');

      const pc = new RTCPeerConnection(iceServers);
      peerConnection.current = pc;
      
      pc.onnegotiationneeded = async () => {
        try {
          if (isNegotiating || !isCaller) return;
          console.log('Negotiation needed');
          setIsNegotiating(true);
          await createAndSendOffer();
        } catch (err) {
          console.error('Error during negotiation:', err);
        }
      };

      pc.onsignalingstatechange = () => {
        setIsNegotiating(pc.signalingState !== 'stable');
      };

      setupPeerConnectionHandlers();

      const stream = await mediaDevices.getUserMedia({
        audio: true,
        video: false,
        echoCancellation: true,
        noiseSuppression: true,
      });

      streamRef.current = stream;
      setLocalStream(stream);

      stream.getTracks().forEach((track) => {
        pc.addTrack(track, stream);
      });

      if (isCaller) {
        await createAndSendOffer();
      }

      setConnectionStatus('Waiting for peer...');
    } catch (err) {
      console.error('Error in setupWebRTC:', err);
      setConnectionStatus('Failed to setup call');
    }
  };

  const setupPeerConnectionHandlers = () => {
    if (!peerConnection.current) return;

    peerConnection.current.onicecandidate = handleIceCandidate;

    peerConnection.current.onconnectionstatechange = () => {
      const state = peerConnection.current.connectionState;
      setConnectionStatus(state.charAt(0).toUpperCase() + state.slice(1));
      setIsConnected(state === 'connected');
    };

    peerConnection.current.oniceconnectionstatechange = () => {
      console.log('ICE connection state:', peerConnection.current.iceConnectionState);
    };

    peerConnection.current.ontrack = (event) => {
      if (event.streams?.[0]) {
        setRemoteStream(event.streams[0]);
      }
    };
  };

  const createAndSendOffer = async () => {
    try {
      if (!peerConnection.current || peerConnection.current.signalingState !== 'stable') {
        console.log('Cannot create offer in current state:', peerConnection.current?.signalingState);
        return;
      }

      const offer = await peerConnection.current.createOffer({
        offerToReceiveAudio: true,
        offerToReceiveVideo: false,
        voiceActivityDetection: true
      });
      
      await peerConnection.current.setLocalDescription(offer);
      
      socket.emit('offer', {
        offer,
        callerId: userId,
        receiverId: receiverId,
      });
    } catch (error) {
      console.error('Error in createAndSendOffer:', error);
      setConnectionStatus('Failed to create offer');
    }
  };

  const handleOffer = async (data) => {
    try {
      if (!peerConnection.current) {
        await setupWebRTC();
      }

      if (peerConnection.current.signalingState !== 'stable') {
        console.log('Cannot handle offer in current state:', peerConnection.current.signalingState);
        return;
      }

      await peerConnection.current.setRemoteDescription(new RTCSessionDescription(data.offer));
      
      const answer = await peerConnection.current.createAnswer();
      await peerConnection.current.setLocalDescription(answer);
      
      socket.emit('answer', {
        answer,
        receiverId: data.callerId,
        callerId: userId,
      });
    } catch (error) {
      console.error('Error in handleOffer:', error);
      setConnectionStatus('Failed to handle offer');
    }
  };

  const handleAnswer = async (data) => {
    try {
      if (peerConnection.current.signalingState === 'stable') {
        console.log('Answer received in stable state, ignoring');
        return;
      }
      
      const remoteDesc = new RTCSessionDescription(data.answer);
      await peerConnection.current.setRemoteDescription(remoteDesc);
    } catch (error) {
      console.error('Error in handleAnswer:', error);
      setConnectionStatus('Failed to handle answer');
    }
  };

  const handleIceCandidate = (event) => {
    if (event.candidate) {
      console.log('Sending ICE candidate to peer...');
      socket.emit('ice-candidate', {
        candidate: event.candidate,
        receiverId: receiverId,
        callerId: userId,
      });
    }
  };

  const handleNewIceCandidate = async (data) => {
    try {
      if (data.candidate) {
        console.log('Adding received ICE candidate...');
        await peerConnection.current.addIceCandidate(data.candidate);
      }
    } catch (error) {
      console.error('Error in handleNewIceCandidate:', error);
    }
  };

  const toggleMute = () => {
    if (localStream) {
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !track.enabled;
        console.log('Audio track enabled:', track.enabled);
        setIsMuted(!track.enabled);
      });
    }
  };

  const toggleSpeaker = () => {
    const newSpeakerStatus = !isSpeakerOn;
    InCallManager.setForceSpeakerphoneOn(newSpeakerStatus);
    setIsSpeakerOn(newSpeakerStatus);
  };

  const handleEndCall = () => {
    socket.emit('endCall', {
      callerId: mode === 'caller' ? userId : receiverId,
      receiverId: mode === 'caller' ? receiverId : userId,
    });
    cleanup();
    navigation.goBack();
  };

  const handleEndCallFromRemote = () => {
    cleanup();
    navigation.goBack();
  };

  const cleanup = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
    }

    if (peerConnection.current) {
      peerConnection.current.close();
    }

    InCallManager.stop();
  };
  
  
  return (
    <View style={styles.container}>
      <View style={styles.topSection}>
        <Text style={styles.callerName}>
          {mode === 'caller' ? 'Unknown Receiver' : 'Unknown Caller'}
        </Text>
        <Text style={styles.callStatus}>{connectionStatus}</Text>
      </View>

      <View style={styles.bottomSection}>
        <TouchableOpacity 
          style={[styles.actionButton, isMuted && styles.actionButtonActive]} 
          onPress={toggleMute}
        >
          {isMuted ? <MicOff /> : <Mic />}
        </TouchableOpacity>

        <TouchableOpacity 
          style={[styles.actionButton, isSpeakerOn && styles.actionButtonActive]} 
          onPress={toggleSpeaker}
        >
          {isSpeakerOn ? <SpeakerOff /> : <Speaker />}
        </TouchableOpacity>

        <TouchableOpacity 
          style={styles.endCallButton} 
          onPress={handleEndCall}
        >
          <Phonecall_end />
        </TouchableOpacity>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'black',
    justifyContent: 'space-between',
  },
  topSection: {
    alignItems: 'center',
    paddingTop: 50,
  },
  callerName: {
    marginTop: 10,
    fontSize: 20,
    color: 'white',
    fontWeight: 'bold',
  },
  callStatus: {
    fontSize: 16,
    color: '#666',
    marginTop: 5,
  },
  bottomSection: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    paddingVertical: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderTopLeftRadius: 30,
    borderTopRightRadius: 30,
  },
  actionButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    padding: 15,
    borderRadius: 50,
  },
  actionButtonActive: {
    backgroundColor: '#666',
  },
  endCallButton: {
    backgroundColor: '#ff3b30',
    padding: 15,
    borderRadius: 50,
  },
});

export default OngoingCallScreen;